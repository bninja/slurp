#!/usr/bin/env python
"""
Script used to slurp (seed, touch or monitor) files. See --help for usage.
"""
from __future__ import with_statement
from argparse import ArgumentParser
import fcntl
import logging
import logging.handlers
import signal
import sys

import slurp


logger = logging.getLogger('slurp-cli')


# common

def configure_log(level):
    level = getattr(logging, level.upper())
    logger = logging.getLogger('')
    logger.setLevel(level)


def configure_stderr():
    logger = logging.getLogger('')
    handler = logging.StreamHandler(sys.stderr)
    fmt = logging.Formatter(
        '%(process)d : %(asctime)s : %(levelname)s : %(name)s : %(message)s')
    handler.setFormatter(fmt)
    logger.addHandler(handler)


def configure_syslog():
    logger = logging.getLogger('')
    handler = logging.handlers.SysLogHandler('/dev/log')
    fmt = logging.Formatter('slurp[%(process)d]: %(message)s')
    handler.setFormatter(fmt)
    logger.addHandler(handler)
    
    
def arg_parser():
    common_parser = ArgumentParser(add_help=False)
    common_parser.add_argument('-l', '--log-level',
        choices=['debug', 'info', 'warn', 'error'], default='info',
        metavar='LEVEL', help='Log level.')
    common_parser.add_argument('--enable-syslog',
        action='store_true',default=False,
        help='Enable system log.')
    common_parser.add_argument('--disable-stderrlog',
        action='store_true', default=False,
        help='Disable stderr log.')
    common_parser.add_argument('-s', '--state-dir',
        default='/var/lib/slurp', metavar='DIR',
        help='State storage directory.')
    common_parser.add_argument('-c', '--conf-file',
        metavar='FILE', default='/etc/slurp/slurp.conf',
        help='Configuration file.')
    common_parser.add_argument(
        '--disable-tracking', action='store_true', default=False,
        help='Disables tracking of ingest progress.')
    common_parser.add_argument(
        '--disable-backfill', action='store_true', default=False,
        help='Disables ingest backfill.')    
    common_parser.add_argument(
        '--include-channel', dest='include_channels',
        action='append', default=[], metavar='CHANNEL',
        help='Channels to explicitly include.')    
    common_parser.add_argument(
        '--exclude-channel', dest='exclude_channels',
        action='append', default=[], metavar='CHANNEL',
        help='Channels to explicitly exclude.')
    
    parents = [common_parser]
    parser = ArgumentParser(
        version=slurp.__version__,
        parents=parents,
        description="""\
slurp is a block parser. It iterates over "entries" in append only sources
(aka files) and sends them along to a sink for further processing. The mapping
from source to sink is called a channel.""")
    
    sub_parsers = parser.add_subparsers(title='sub-commands')
    seed_arg_parser(sub_parsers, parents)
    touch_arg_parser(sub_parsers, parents)
    monitor_arg_parser(sub_parsers, parents)
    
    return parser


def parse_sink(sink):
    if sink == 'stdout':
        sink = 'file:/dev/stdout' 
    if sink == 'null':
        sink = 'file:/dev/null'
    if sink == 'dbg':
        sink = 'dbg'
    type, _, arg = sink.partition(':')
    return type, arg


def load_conf(args):
    conf = slurp.load_conf(
        args.conf_file, args.include_channels, args.exclude_channels)
    if args.disable_tracking:
        conf['tracking_file'] = None
    if args.disable_backfill:
        for channel_conf in conf['channels']:
            channel_conf['backfill'] = False
    sink = getattr(args, 'sink', None)
    if sink:
        sink = parse_sink(sink)
        for channel_conf in conf['channels']:
            channel_conf['sink'] = sink 
    return conf


class Flock(object):
    
    def __init__(self, path):
        self.path = path
        self.fo = None

    def acquire(self, timeout):
        logger.info('locking %s', self.path)
        self.fo = open(self.path, 'w')
        prev_handler = signal.signal(signal.SIGALRM, self._timeout)
        signal.alarm(timeout)
        try:    
            fcntl.flock(self.fo.fileno(), fcntl.LOCK_EX)
        finally:
            signal.alarm(0)
            signal.signal(signal.SIGALRM, prev_handler)
        logger.info('locked %s', self.path)
    
    def release(self):
        logger.info('releasing %s', self.path)
        fcntl.flock(self.fo.fileno(), fcntl.LOCK_UN)
        self.fo.close()
        
    def _timeout(self, signum, frame):
        logger.warning('unable to lock %s', self.path)


# seed

def seed_arg_parser(sub_parsers, parents):
    parser = sub_parsers.add_parser('seed', parents=parents,
        description="""
Initializes channel tracking information for PATHs.""")
    parser.add_argument('paths',
        nargs='*', metavar='PATH', help='Path to file or directory.')
    parser.set_defaults(command=seed)
    return parser


def seed(args):
    configure_log(args.log_level)
    if not args.disable_stderrlog:
        configure_stderr()
    if args.enable_syslog:
        configure_syslog()
    conf = load_conf(args)
    channels = slurp.create_channels(conf['channels'])
    slurp.seed(channels, args.paths, conf['tracking_file'])


# touch

def touch_arg_parser(sub_parsers, parents):
    parser = sub_parsers.add_parser('touch', parents=parents,
        description="""\
Triggers ingest of PATHs by interested channels.""")
    parser.add_argument('paths',
        nargs='*', metavar='PATH', help='Path to file or directory.')
    parser.add_argument(
        '--sink', choices=['stdout', 'null', 'dbg'], default=None,
        metavar='NAME', help='Force channels to use a sink.')
    parser.set_defaults(command=touch)
    return parser


def touch(args):
    configure_log(args.log_level)
    if not args.disable_stderrlog:
        configure_stderr()
    if args.enable_syslog:
        configure_syslog()
    conf = load_conf(args)
    channels = slurp.create_channels(conf['channels'])
    slurp.touch(channels, args.paths, conf['tracking_file'])


# monitor

def monitor_arg_parser(sub_parsers, parents):
    parser = sub_parsers.add_parser('monitor', parents=parents,
        description="""\
Monitors PATHs for changes and triggers ingest by interested channels.""")
    parser.add_argument('paths',
        nargs='*', metavar='PATH', help='Path to file or directory.')
    parser.add_argument(
        '-d', '--daemonize', action='store_true', default=False,
        help='Daemonize the monitor.')
    parser.add_argument(
        '-w', '--workers', type=int, default=1,
        help='Number of workers to use for un-tagged channels.')
    parser.add_argument(
        '--pid-file', default=None,
        metavar='FILE', help='PID file.')
    parser.add_argument(
        '--lock-file', default=None,
        metavar='FILE', help='Lock file.')
    parser.add_argument(
        '--lock-timeout', default=5, type=int,
        metavar='SECONDS', help='Lock timeout in SECONDS.')
    parser.add_argument(
        '--sink', choices=['stdout', 'null', 'dbg'], default=None,
        metavar='NAME', help='Force all channels to use a particular sink.')
    parser.set_defaults(command=monitor)
    return parser
    

def monitor(args):
    configure_log(args.log_level)
    master = slurp.Master(
        conf_file=args.conf_file,
        worker_count=args.workers,
        op=slurp.monitor)
    if args.include_channels:
        master.include_channels = args.include_channels 
    if args.exclude_channels:
        master.exclude_channels = args.exclude_channels
    if args.disable_backfill:
        master.backfill = False
    if args.disable_tracking:
        master.tracking_file = None
    if args.sink:
        master.sink = parse_sink(args.sink)
    if args.pid_file:
        from lockfile.pidlockfile import PIDLockFile
        pid_file = PIDLockFile(args.pid_file)
    else:
        pid_file = None
    if not args.disable_stderrlog:
        configure_stderr()
    if args.daemonize: 
        from daemon import DaemonContext
        with DaemonContext(
                 pidfile=pid_file,
                 files_preserve=[],
                 signal_map=master.signal_map):
            if args.enable_syslog:
                configure_syslog()  # NOTE: do this after daemonize
            if args.lock_file:
                lock = Flock(args.lock_file)
                lock.acquire(timeout=args.lock_timeout)
            try:
                master(args.paths)
            except Exception, ex:
                logger.exception(ex)
                raise
            finally:
                if args.lock_file:
                    lock.release()
    else:
        if args.enable_syslog:
            configure_syslog()  # NOTE: do this after daemonize
        if args.lock_file:
            lock = Flock(args.lock_file)
            lock.acquire(timeout=args.lock_timeout)
        try:
            master(args.paths)
        finally:
            if args.lock_file:
                lock.release()

# main

def main():
    parser = arg_parser()
    args = parser.parse_args()
    args.command(args)


if __name__ == '__main__':
    main()
