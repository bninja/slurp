#!/usr/bin/env python
"""
Script used to slurp (seed, eat or monitor) logs. You can also use it as a
daemon monitor. For an example init script wrapping the daemon monitor as a
service see contrib/slurp.

See --help for usage.
"""
from __future__ import with_statement
import functools
import logging
import logging.handlers
from optparse import OptionParser
import os
import signal
import sys
import tempfile

from daemon import DaemonContext
from lockfile.pidlockfile import PIDLockFile

import slurp


logger = logging.getLogger('slurp')


def configure_log(level):
    logger = logging.getLogger('')
    logger.setLevel(level)


def configure_stderr():
    logger = logging.getLogger('')
    handler = logging.StreamHandler(sys.stderr)
    fmt = logging.Formatter(
        '%(asctime)s : %(levelname)s : %(name)s : %(message)s')
    handler.setFormatter(fmt)
    logger.addHandler(handler)


def configure_syslog():
    logger = logging.getLogger('')
    handler = logging.handlers.SysLogHandler('/dev/log')
    fmt = logging.Formatter('slurp[%(process)d]: %(message)s')
    handler.setFormatter(fmt)
    logger.addHandler(handler)


class Manager():
    """
    Used to manage the monitor in daemon mode.
    """

    class Reload(Exception):
        """
        Raised to reload the configuration.
        """
        pass


    class Terminate(Exception):
        """
        Raised to gracefully terminate.
        """
        pass

    
    def __init__(self, create_conf):
        self._conf = None
        self.create_conf = create_conf
        
    @property
    def conf(self):
        if not self._conf:
            logger.info('creating configuration')
            self._conf = self.create_conf() 
        return self._conf

    @property
    def signal_map(self):
        return {
            signal.SIGHUP: self.on_reload,
            signal.SIGTERM: self.on_terminate,
            }
    
    def on_reload(self, signum, frame):
        logger.info('reloading')
        self._conf = None
        raise self.Reload()
    
    def on_terminate(self, signum, frame):
        logger.info('terminating')
        raise self.Terminate()
    
    def loop(self, paths):
        while True:
            try:
                slurp.monitor(paths, self.conf)
            except Manager.Reload:
                continue
            except Manager.Terminate:
                break


def main():
    opt_parser = OptionParser(
        version=slurp.__version__,
        usage="""
%prog s|seed path-1 .. path-n [options]
%prog m|monitor path-1 .. path-n [options]
%prog e|eat path-1 .. path-n [options]\
""")
    opt_parser.add_option(
        '-s', '--state-path', default=tempfile.gettempdir())
    opt_parser.add_option(
        '-c', '--consumer', dest='consumers', action='append', default=[])
    opt_parser.add_option(
        '-l', '--log-level', choices=['debug', 'info', 'warn', 'error'],
        default='warn')
    opt_parser.add_option(
        '--enable-syslog', action='store_true', default=False)
    opt_parser.add_option(
        '--disable-stderrlog', action='store_true', default=False)
    opt_parser.add_option(
        '-d', '--daemonize', action='store_true', default=False)
    opt_parser.add_option(
        '--disable-locking', action='store_true', default=False)
    opt_parser.add_option(
        '--lock-timeout', type='int', default=None)
    opt_parser.add_option(
        '--disable-tracking', action='store_true', default=False)
    opt_parser.add_option(
        '--pid-file', default=None)
    opt_parser.add_option(
        '--sink', choices=['print', 'null'], default=None)
    opt_parser.add_option(
        '--batch-size', type='int', default=None)

    (opts, args) = opt_parser.parse_args()

    if not args:
        raise Exception(opt_parser.get_usage())
    cmd = args[0]
    if cmd not in ('s', 'seed', 'm', 'monitor', 'e', 'eat'):
        raise Exception(opt_parser.get_usage())
    paths = args[1:]

    log_level = getattr(logging, opts.log_level.upper())
    configure_log(log_level)
    if not opts.disable_stderrlog:
        configure_stderr()

    consumer_paths = [
        os.path.abspath(os.path.expanduser(os.path.expandvars(consumer_path)))
        for consumer_path in opts.consumers]

    sink = None
    if opts.sink == 'null':
        sink = slurp.null_sink
    elif opts.sink == 'print':
        sink = slurp.print_sink

    # NOTE: intentionally deferred
    create_conf = functools.partial(
        slurp.Conf,
        opts.state_path,
        consumer_paths,
        not opts.disable_locking,
        opts.lock_timeout,
        not opts.disable_tracking,
        sink,
        opts.batch_size)

    if cmd in ('s', 'seed'):
        # NOTE: intentionally deferred 
        if opts.enable_syslog:
            configure_syslog(log_level)
        slurp.seed(paths or sys.stdin, create_conf())
    elif cmd in ('m', 'monitor'):
        if opts.daemonize:
            mgr = Manager(create_conf)
            if opts.pid_file:
                pid_file = PIDLockFile(opts.pid_file)
            else:
                pid_file = None
            with DaemonContext(
                    pidfile=pid_file,
                    files_preserve=[],
                    signal_map=mgr.signal_map):
                # NOTE: intentionally deferred
                if opts.enable_syslog:
                    configure_syslog()
                try:
                    mgr.loop()
                except Exception, ex:
                    logger.exception(ex)
                    raise
        else:
            # NOTE: intentionally deferred
            if opts.enable_syslog:
                configure_syslog()
            slurp.monitor(paths or sys.stdin, create_conf())
    elif cmd in ('e', 'eat'):
        # NOTE: intentionally deferred
        if opts.enable_syslog:
            configure_syslog()
        slurp.eat(paths or sys.stdin, create_conf())


if __name__ == '__main__':
    main()
