#!/usr/bin/env python
import logging
import logging.handlers
from optparse import OptionParser
import os
import sys
import tempfile

from daemon import DaemonContext
from lockfile import FileLock

import slurp


logger = logging.getLogger('slurp')


def configure_logging(level, enable_stderr, enable_syslog):
    logger = logging.getLogger('')
    logger.setLevel(level)
    if enable_stderr:
        handler = logging.StreamHandler(sys.stderr)
        fmt = logging.Formatter(
            '%(asctime)s : %(levelname)s : %(name)s : %(message)s')
        handler.setFormatter(fmt)
        logger.addHandler(handler)
    if enable_syslog:
        handler = logging.handlers.SysLogHandler('/dev/log')
        fmt = logging.Formatter('slurp[%(process)d]: %(message)s')
        handler.setFormatter(fmt)
        logger.addHandler(handler)


def main():
    opt_parser = OptionParser(usage="""
%prog s|seed path-1 .. path-n [options]
%prog m|monitor path-1 .. path-n [options]
%prog e|eat path-1 .. path-n [options]\
""")
    opt_parser.add_option(
        '-s', '--state-path', default=tempfile.gettempdir())
    opt_parser.add_option(
        '-c', '--consumer', dest='consumers', action='append', default=[])
    opt_parser.add_option(
        '-l', '--log-level', choices=['debug', 'info', 'warn', 'error'],
        default='warn')
    opt_parser.add_option(
        '--enable-syslog', action='store_true', default=False)
    opt_parser.add_option(
        '--disable-stderrlog', action='store_true', default=False)
    opt_parser.add_option(
        '-d', '--daemonize', action='store_true', default=False)
    opt_parser.add_option(
        '--disable-locking', action='store_true', default=False)
    opt_parser.add_option(
        '--lock-timeout', type='int', default=None)
    opt_parser.add_option(
        '--disable-tracking', action='store_true', default=False)
    opt_parser.add_option(
        '--pid-file', default=None)
    opt_parser.add_option(
        '--sink', choices=['print', 'null'], default=None)
    opt_parser.add_option(
        '--batch-size', type='int', default=None)

    (opts, args) = opt_parser.parse_args()

    if not args:
        raise Exception(opt_parser.get_usage())
    cmd = args[0]
    if cmd not in ('s', 'seed', 'm', 'monitor', 'e', 'eat'):
        raise Exception(opt_parser.get_usage())
    paths = args[1:]

    log_level = getattr(logging, opts.log_level.upper())
    configure_logging(
        log_level, not opts.disable_stderrlog, opts.enable_syslog)

    consumer_paths = [
        os.path.abspath(os.path.expanduser(os.path.expandvars(consumer_path)))
        for consumer_path in opts.consumers]

    sink = None
    if opts.sink == 'null':
        sink = slurp.null_sink
    elif opts.sink == 'print':
        sink = slurp.print_sink

    conf = slurp.Conf(
        opts.state_path,
        consumer_paths,
        not opts.disable_locking,
        opts.lock_timeout,
        not opts.disable_tracking,
        sink,
        opts.batch_size)

    if cmd in ('s', 'seed'):
        slurp.seed(paths or sys.stdin, conf)
    elif cmd in ('m', 'monitor'):
        if opts.daemonize:
            if opts.pid_file:
                pid_file = FileLock(opts.pid_file)
            else:
                pid_file = None
            with DaemonContext(pidfile=pid_file):
                slurp.monitor(paths, conf)
        else:
            slurp.monitor(paths or sys.stdin, conf)
    elif cmd in ('e', 'eat'):
        slurp.eat(paths or sys.stdin, conf)


if __name__ == '__main__':
    main()
